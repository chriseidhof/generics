{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE MultiParamTypeClasses #-}
module User where

import ModelName
import Records
import Relations
import Database
import qualified Database.Columns as C
import Database.Values
import Database.Parse
import Database.HDBC.Sqlite3 (Connection, connectSqlite3)
import Data.Time (UTCTime)

test = do
  conn <- connectSqlite3 "example.sqlite3"
  runDB conn $ do
    user <- find (undefined :: User) 1
    fillBelongsTo (fromMaybe' "" user) relPost
-- User datatype

data User = User {name :: String, password :: String, age :: Int, post :: BelongsTo Post}
 deriving (Show)
data Post = Post {title :: String, body :: String, date :: UTCTime}
 deriving (Show)

instance Rep ModelName UTCTime where rep = error "No modelName for UTCTime"
instance Rep C.Columns UTCTime where rep = C.ignore
instance Rep Parse     UTCTime where rep = parseUsingRead

-- TODO: the rest will be generated by TH

instance (Labeled g, Rep g String, Rep g (BelongsTo Post)) => Rep g User where
  rep = rUser rep rep

instance (Labeled g, Rep g String, Rep g UTCTime) => Rep g Post where
  rep = rPost rep rep

rUser :: (Labeled g) => g String -> g (BelongsTo Post) -> g User
rUser rString rBtPost = ltype epUser (lcon "User" $ lfield "name" rString 
                                           `lprod` (lfield "password" rString 
                                           `lprod` (lfield "age" lint `lprod` lfield "post" rBtPost))
                                      )

rPost :: (Labeled g) => g String -> g UTCTime -> g Post
rPost rString rTime = ltype epPost (lcon "Post" $ lfield "title" rString 
                                   `lprod` (lfield "body"  rString
                                   `lprod` (lfield "date"  rTime))
                             )

epUser = EP fromUser toUser
epPost = EP fromPost toPost

fromUser :: User -> (String, (String, (Int, BelongsTo Post)))
fromUser (User x1 x2 x3 x4) = (x1, (x2, (x3, x4)))

fromPost :: Post -> (String, (String, UTCTime))
fromPost (Post x1 x2 x3) = (x1, (x2, x3))


toUser (x1, (x2, (x3, x4))) = (User x1 x2 x3 x4)
toPost (x1, (x2, x3)) = (Post x1 x2 x3)

-- These are the relations
relPost = RBT post $ \u p -> u {post = p}
